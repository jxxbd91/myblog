### 登录注册

登录功能点：用户名、密码、登录三次错误之后出现图形验证码
  登录：
    1、通过session保持登录状态，设置最长的session时间，并且可以保持长登录
    2、实现单点登录 // 较为复杂暂时不实现
注册功能点：用户名、密码、重复密码、图形验证码

找回密码：密码重置

### 主页

### 详情

### 回复

### 发表
  字段： 标题、内容、作者、创建时间

### 重新编辑

### 功能点记录
1、
  cookie签名
  签名的作用： 确定从服务端拿到的cookie是从后端生成出去的
  举例说明：
    例如在服务端的相应中设置了 res.cookie(name, value)。在前端接口请求成功之后就会在浏览器的cookie中添加该生成的cookie，但是客户端或者请求拦截器可以将cookie中的value修改掉。这样后端拿到的cookie就不是原来生成的cookie
    如果在生成cookie的时候给cookie添加签名，然后返回给前端。这样如果前端或者请求拦截器修改了cookie中的value值。当后端拿到这个cookie时发现值变化了，就不会解析出来被修改的value，而是当作错误进行处理
  
  生成cookie签名的方式：

    // 设置签名串
    app.use(cookieParser('自定义的签名串'))

    // 给cookie设置签名
    res.cookie(name, value, {
      signed: true
    })


    // 获取签名cookie
    let cookies = req.signedCookies
    // 这样可以获得一个cookie对象，如果后端在浏览器中种下的cookie被篡改了，得到的cookies就是一个false，如果没有发生篡改得到的cookies就是一个正确的cookie对象

2、session
  session的作用，session就是会话，基本功能类似于cookie，并且实现也是基于cookie的。
  会话的意义：由于http协议是一个无状态的协议，服务端接收到的请求无法确定是从哪个客户端发送过来的。这对于需要有状态的场景就没有办法让服务端识别请求是不是同一个客户端发送的。对于这种场景的解决办法是客户端每次在请求头或者请求体中带一个标志，表明自己的身份。服务端在接收到了这种请求的时候就能够辨别请求的客户端是谁。
   cookie就具有这样一个作用。以登录为例，在登录成功之后，服务端会在响应中增加cookie，cookie的内容是登录用户的信息，客户端在接收到响应之后就会将获得的cookie存在浏览器中，这样以后的每次请求都会带上cookie，服务端接收到请求之后会解析cookie从而获得用户信息，从而在一个无状态的http请求中获得用户信息。
   cookie是将用户信息存储在cookie中，这样做会出现一些问题。由于浏览器中的数据是不安全的，很容易被获得并且被修改。这样就会带来安全隐患。而在session中可以较好地处理用户信息泄露这一问题，同样以登录为例，在登录成功之后服务端同样要在响应中增加cookie，只不过cookie的值不是用户信息而是一个id。这个id是一个键，服务端在生成cookie的同时会将用户信息写入服务端的内存（或者redis、database）中，写入的这段信息的键就是id。这样在客户端中存储的信息就只是一个id，可以较好地处理用户信息泄露的问题。
   express-session 中session的实现

    const session = require('express-session')
    // 以中间件的形式使用session
    app.use(session({
      // options  一些配置信息
    }))

    // 在登录成功的信息中写入session
    app.post('/login', (request, response) => {
      if (登录成功) {
        request.session.session名称 = session值
      }
    })

    // 通过上面的方式就可以生成session了，这样在服务端的内存中就能保存生成的session，并且会自动跟cookie中的键生成关联

    // session的获取
    app.use((request, response) => {
      let ses = request.session.session名称
      // 通过上面的方式就能获取到session
    })

  session中的配置:


3、react-router-dom
  嵌套路由

4、react项目中css文件的处理
 css module
 react 中局部样式的处理方式采用css module的方式进行处理，css需要配合webpack使用，在webpack中通过css-loader进行编译。需要在css-loader中设置modules属性为true，并且可以通过localIdentName来指定生成的css类的名称。
  在react组件中使用css module 样式，需要通过引入指定css，然后就可以使用了。
  
  // 在webpack中的配置
  {
    loader: require.resolve('css-loader'),
    options: {
      modules: true, // 启用css module
      localIdentName: '[name]__[local]-[hash:base64:5]', // 指定生成的类名
      importLoaders: 1,
    },
  }

css样式声明跟普通的css写法一样

以下是在组件中的使用
  // 引入css
  import styles from './style/style.css

  // 使用
  render() {
    return (
      <div className={styles.css类名}></div>
    )
  }

  通过以上的简单步骤就可以实现css module。主要是借助了webpack的css-loader来实现的。

  需要注意的是一旦给css-loader配置了modules属性，所有引入的css样式都是局部样式，如果需要使用全局样式需要给指定样式包裹:global,例如：
    :global(.css类名) {
      // 设置具体样式
    }

5、react中的全局组件
  全局组件的作用
    在项目中使用全局组件可以简化组件在jsx中的声明，直接通过函数调用的方式进行创建组件。可以让开发更加灵活，有效。比较适用于全局的对话框、提示框、用户提示等业务场景。
  在react中的实现
    在react中使用全局组件首先需要声明你需要完成功能的组件，以notice组件为例，在项目中创建 NoticeComp.jsx 组件，简化后的代码如下：

    // NoticeComp.jsx
    export default class NoticeComp extends Component {
      constructor(props) {
        super(props)
        this.state = {
          visible: this.props.visible
        }
      }

      close() {
        this.props.closeFn.call(this.props.self)
      }

      render() {
        return (
          <div>
            <p>{this.props.msg}</p>
            <span onClick={this.close.bind(this)}>关闭</span>
          </div>
        )
      }
    }

    组件中通过props的方式接收close方法的回调函数，以回调的形式来实现关闭弹窗的响应。上面的代码是常规的react组件写法。
    下面来实现如何将上面的组件通过方法调用的形式来进行创建和销毁，在这种业务场景中弹窗可以实现通过单例模式来实现（通过条件判断的形式来控制每次都只能出现一个实例）或者允许生成多个实例，每个实例自己维护自己的状态这种方式，以下是Notice.js 的具体实现：

    // Notice.js
    class Notice {
      constructor () {
        this.visible = false
        this.div = null
        this.props = {}
      }
      show(props) {
        this.visible = true
        this.props = props
        init.call(this)
      }
    }

    /**
    * close 方法变成私有方法
    */
    function close() {
      ReactDOM.unmountComponentAtNode(this.div)
      document.body.removeChild(this.div)
    }

    /**
    * init 方法变成私有
    */
    function init() {
      this.div = document.createElement('div')
      document.body.append(this.div)
      ReactDOM.render(<NoticeComp visible={this.visible} closeFn={close} self={this} {...this.props}></NoticeComp>, this.div)
    }

    export default () => {
      return new Notice()
    }

    对于上面的代码需要说明的是：
      1、整体以类的形式进行代码组织，这样就抛开了单例模式，允许多个实例的存在。最终通过导出一个函数，函数中返回一个对象的形式进行模块导出。这么做是因为在es6 模块中导出的是值的引用，所以不这么做的话就会出现值的引用互相影响的情况。
      
      摘抄自阮一峰【
        讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。

        它们有两个重大差异。

        CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
        CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
      】

      2、由于es class中没有私有方法和私有变量的概念，所以将 init 和 close 两个方法放在class外进行保护

      3、上面的核心代码实际上只有
          ReactDOM.render(<NoticeComp visible={this.visible} closeFn={close} self={this} {...this.props}></NoticeComp>, this.div)
          ReactDOM.unmountComponentAtNode(this.div)
          两句

    通过上面的两个文件就能在你需要的代码中通过函数式调用的形式进行全局组件的创建
    
    import Notice from './Notice.js

    // 在某个方法中
    fn () {
      // 进行组件创建
      Notice().show()
    }

6、node图形验证码

    node中实现图像验证码需要借助第三方的中间件 svg-captcha
    实现 三次登录失败后提示需要图形验证码的功能：
    
7、passport
